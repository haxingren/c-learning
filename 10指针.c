#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

////为了有效分配利用内存，内存被划分为一个个内存单元，每一个单元的大小是一个字节（1byte）
//为了有效访问这些内存单元，为每一个内存单元编号，这些编号就是内存单元的地址，内存单元的地址，也被称为指针
int main()
{
	int a = 10;
	&a;//取地址操作符
	//经过调试，我们可以看到a这个数据的地址是0x008FFC68，而0a 00 00 00是内存的数据
	//                        其实这段数据有四个地址，这是68 69 6A 6B,取地址只取第一位
	//已知二进制是由0和1组成，十进制由1~9组成，而16进制本应由1~15组成但10，11，12这些数字重复了，
	//所以规定用a,b,c,d,e,f这些字符依次代表10，11，12
	//在二进制里，十进制的10是1010，int变量要给他4个字节的存储空间即32个bit所以是
	//0000 0000 0000 0000 0000 0000 0000 1010
	//太长了，写成16进制则是
	//0    0    0    0    0    0    0    a
	//(00 00 00 0a)这就是存储数据
	printf("%p\n", &a);//打印出了00AFF7E0跟刚刚调试不一样，因为变量，每一次运行都会重新创建，所以地址也是重新创建的
	//如何存储地址呢，使用指针变量
	//指针变量就是存储变量地址（指针）的变量
	int* p = &a;//p就是存放了a的地址的变量
	printf("%p\n", p);//打印指针
	//int*,int表示存放的指针是整型变量的指针，*代表这是个指针变量
	char ch = 'q';
	//如果要存放ch的指针
	char* l = &ch;

	//通过指针变量，我们也可以反向通过指针找到其所对应的对象，甚至对其赋值
	*p = 20;//这里*是一个操作符，解引用操作符，*p就是p指向的对象，就是a
	printf("%d\n", a);//这会打印出20而不是10，代表通过*p确实找到了变量a并改变了他的值



	////指针变量的大小
	//sizeof最后是用%zu来输出,而不是用%d
	printf("%zu\n", sizeof(char*));
	printf("%zu\n", sizeof(short*));
	printf("%zu\n", sizeof(int*));
	printf("%zu\n", sizeof(long*));
	printf("%zu\n", sizeof(float*));
	printf("%zu\n", sizeof(double*));

	//结果都是4，这是因为不过指针存放的是什么类型的变量的地址，他都是指针变量，他存放的都是地址，
	// 指针变量的大小取决于地址的大小
	//在32位机器（x86）上地址的大小都是32个bit位，即4个字节
	//如果在64位机器（x64），那么地址的大小是64个bit位，即8个字节

	return 0;
}